// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { acceptInvitation, addHouseholdMember, archiveBill, archiveIncome, cloneTransaction, createAccount, createAllocation, createBill, createBudget, createCategory, createHousehold, createIncome, createInvitation, createRecipient, createTransaction, createTransfer, declineInvitation, deleteAccount, deleteBill, deleteBudget, deleteCategory, deleteHousehold, deleteIncome, deleteRecipient, deleteTransaction, deleteTransfer, getAccount, getAccountBalance, getAccountBalanceHistory, getBillInstance, getBudget, getBudgetSnapshotHistory, getCategory, getHousehold, getHouseholdMembers, getIncome, getOrCreateRecipient, getRecipient, getTransaction, getTransactionsGroupedByCategory, getUnallocatedFunds, linkAccountToBudget, linkCategoryToBudget, listAccounts, listAllocations, listBills, listBudgets, listCategories, listHouseholdInvitations, listHouseholds, listIncomes, listMyInvitations, listRecipients, listTransactions, listTransfers, type Options, removeHouseholdMember, revokeInvitation, toggleAccountArchive, transferAllocation, unlinkAccountFromBudget, unlinkCategoryFromBudget, updateAccount, updateBill, updateBillInstance, updateBudget, updateCategory, updateHousehold, updateIncome, updateRecipient, updateTransaction, updateTransfer } from '../sdk.gen';
import type { AcceptInvitationData, AddHouseholdMemberData, ArchiveBillData, ArchiveBillResponse, ArchiveIncomeData, ArchiveIncomeResponse, CloneTransactionData, CloneTransactionResponse, CreateAccountData, CreateAccountResponse, CreateAllocationData, CreateAllocationResponse, CreateBillData, CreateBillResponse, CreateBudgetData, CreateBudgetResponse, CreateCategoryData, CreateCategoryResponse, CreateHouseholdData, CreateHouseholdResponse, CreateIncomeData, CreateIncomeResponse, CreateInvitationData, CreateInvitationResponse, CreateRecipientData, CreateRecipientResponse, CreateTransactionData, CreateTransactionResponse, CreateTransferData, CreateTransferResponse, DeclineInvitationData, DeleteAccountData, DeleteAccountResponse, DeleteBillData, DeleteBudgetData, DeleteBudgetResponse, DeleteCategoryData, DeleteCategoryResponse, DeleteHouseholdData, DeleteIncomeData, DeleteIncomeResponse, DeleteRecipientData, DeleteTransactionData, DeleteTransactionResponse, DeleteTransferData, DeleteTransferResponse, GetAccountBalanceData, GetAccountBalanceHistoryData, GetAccountBalanceHistoryResponse, GetAccountBalanceResponse, GetAccountData, GetAccountResponse, GetBillInstanceData, GetBillInstanceResponse, GetBudgetData, GetBudgetResponse, GetBudgetSnapshotHistoryData, GetBudgetSnapshotHistoryResponse, GetCategoryData, GetCategoryResponse, GetHouseholdData, GetHouseholdMembersData, GetHouseholdMembersResponse, GetHouseholdResponse, GetIncomeData, GetIncomeResponse, GetOrCreateRecipientData, GetOrCreateRecipientResponse, GetRecipientData, GetRecipientResponse, GetTransactionData, GetTransactionResponse, GetTransactionsGroupedByCategoryData, GetTransactionsGroupedByCategoryResponse, GetUnallocatedFundsData, GetUnallocatedFundsResponse, LinkAccountToBudgetData, LinkCategoryToBudgetData, ListAccountsData, ListAccountsResponse, ListAllocationsData, ListAllocationsResponse, ListBillsData, ListBillsResponse, ListBudgetsData, ListBudgetsResponse, ListCategoriesData, ListCategoriesResponse, ListHouseholdInvitationsData, ListHouseholdInvitationsResponse, ListHouseholdsData, ListHouseholdsResponse, ListIncomesData, ListIncomesResponse, ListMyInvitationsData, ListMyInvitationsResponse, ListRecipientsData, ListRecipientsResponse, ListTransactionsData, ListTransactionsResponse, ListTransfersData, ListTransfersResponse, RemoveHouseholdMemberData, RevokeInvitationData, ToggleAccountArchiveData, ToggleAccountArchiveResponse, TransferAllocationData, TransferAllocationResponse, UnlinkAccountFromBudgetData, UnlinkCategoryFromBudgetData, UpdateAccountData, UpdateAccountResponse, UpdateBillData, UpdateBillInstanceData, UpdateBillInstanceResponse, UpdateBillResponse, UpdateBudgetData, UpdateBudgetResponse, UpdateCategoryData, UpdateCategoryResponse, UpdateHouseholdData, UpdateHouseholdResponse, UpdateIncomeData, UpdateIncomeResponse, UpdateRecipientData, UpdateRecipientResponse, UpdateTransactionData, UpdateTransactionResponse, UpdateTransferData, UpdateTransferResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const listHouseholdsQueryKey = (options?: Options<ListHouseholdsData>) => createQueryKey('listHouseholds', options);

/**
 * List all households for the authenticated user
 */
export const listHouseholdsOptions = (options?: Options<ListHouseholdsData>) => queryOptions<ListHouseholdsResponse, DefaultError, ListHouseholdsResponse, ReturnType<typeof listHouseholdsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listHouseholds({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listHouseholdsQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listHouseholdsInfiniteQueryKey = (options?: Options<ListHouseholdsData>): QueryKey<Options<ListHouseholdsData>> => createQueryKey('listHouseholds', options, true);

/**
 * List all households for the authenticated user
 */
export const listHouseholdsInfiniteOptions = (options?: Options<ListHouseholdsData>) => infiniteQueryOptions<ListHouseholdsResponse, DefaultError, InfiniteData<ListHouseholdsResponse>, QueryKey<Options<ListHouseholdsData>>, number | Pick<QueryKey<Options<ListHouseholdsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListHouseholdsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listHouseholds({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listHouseholdsInfiniteQueryKey(options)
});

/**
 * Create a new household
 */
export const createHouseholdMutation = (options?: Partial<Options<CreateHouseholdData>>): UseMutationOptions<CreateHouseholdResponse, DefaultError, Options<CreateHouseholdData>> => {
    const mutationOptions: UseMutationOptions<CreateHouseholdResponse, DefaultError, Options<CreateHouseholdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createHousehold({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a household (must have no budgets)
 */
export const deleteHouseholdMutation = (options?: Partial<Options<DeleteHouseholdData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteHouseholdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteHouseholdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteHousehold({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getHouseholdQueryKey = (options: Options<GetHouseholdData>) => createQueryKey('getHousehold', options);

/**
 * Get a specific household
 */
export const getHouseholdOptions = (options: Options<GetHouseholdData>) => queryOptions<GetHouseholdResponse, DefaultError, GetHouseholdResponse, ReturnType<typeof getHouseholdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getHousehold({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHouseholdQueryKey(options)
});

/**
 * Update a household
 */
export const updateHouseholdMutation = (options?: Partial<Options<UpdateHouseholdData>>): UseMutationOptions<UpdateHouseholdResponse, DefaultError, Options<UpdateHouseholdData>> => {
    const mutationOptions: UseMutationOptions<UpdateHouseholdResponse, DefaultError, Options<UpdateHouseholdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateHousehold({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getHouseholdMembersQueryKey = (options: Options<GetHouseholdMembersData>) => createQueryKey('getHouseholdMembers', options);

/**
 * Get household members with user details (from Clerk)
 */
export const getHouseholdMembersOptions = (options: Options<GetHouseholdMembersData>) => queryOptions<GetHouseholdMembersResponse, DefaultError, GetHouseholdMembersResponse, ReturnType<typeof getHouseholdMembersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getHouseholdMembers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHouseholdMembersQueryKey(options)
});

export const getHouseholdMembersInfiniteQueryKey = (options: Options<GetHouseholdMembersData>): QueryKey<Options<GetHouseholdMembersData>> => createQueryKey('getHouseholdMembers', options, true);

/**
 * Get household members with user details (from Clerk)
 */
export const getHouseholdMembersInfiniteOptions = (options: Options<GetHouseholdMembersData>) => infiniteQueryOptions<GetHouseholdMembersResponse, DefaultError, InfiniteData<GetHouseholdMembersResponse>, QueryKey<Options<GetHouseholdMembersData>>, number | Pick<QueryKey<Options<GetHouseholdMembersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetHouseholdMembersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getHouseholdMembers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getHouseholdMembersInfiniteQueryKey(options)
});

/**
 * Remove a user from a household
 */
export const removeHouseholdMemberMutation = (options?: Partial<Options<RemoveHouseholdMemberData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveHouseholdMemberData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveHouseholdMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeHouseholdMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add a user to a household
 */
export const addHouseholdMemberMutation = (options?: Partial<Options<AddHouseholdMemberData>>): UseMutationOptions<unknown, DefaultError, Options<AddHouseholdMemberData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddHouseholdMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addHouseholdMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listAccountsQueryKey = (options: Options<ListAccountsData>) => createQueryKey('listAccounts', options);

/**
 * List accounts for a household
 */
export const listAccountsOptions = (options: Options<ListAccountsData>) => queryOptions<ListAccountsResponse, DefaultError, ListAccountsResponse, ReturnType<typeof listAccountsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listAccounts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAccountsQueryKey(options)
});

export const listAccountsInfiniteQueryKey = (options: Options<ListAccountsData>): QueryKey<Options<ListAccountsData>> => createQueryKey('listAccounts', options, true);

/**
 * List accounts for a household
 */
export const listAccountsInfiniteOptions = (options: Options<ListAccountsData>) => infiniteQueryOptions<ListAccountsResponse, DefaultError, InfiniteData<ListAccountsResponse>, QueryKey<Options<ListAccountsData>>, number | Pick<QueryKey<Options<ListAccountsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListAccountsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAccounts({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAccountsInfiniteQueryKey(options)
});

/**
 * Create a new account
 */
export const createAccountMutation = (options?: Partial<Options<CreateAccountData>>): UseMutationOptions<CreateAccountResponse, DefaultError, Options<CreateAccountData>> => {
    const mutationOptions: UseMutationOptions<CreateAccountResponse, DefaultError, Options<CreateAccountData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAccount({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an account (must have no transactions, bills, or transfers)
 */
export const deleteAccountMutation = (options?: Partial<Options<DeleteAccountData>>): UseMutationOptions<DeleteAccountResponse, DefaultError, Options<DeleteAccountData>> => {
    const mutationOptions: UseMutationOptions<DeleteAccountResponse, DefaultError, Options<DeleteAccountData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAccount({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAccountQueryKey = (options: Options<GetAccountData>) => createQueryKey('getAccount', options);

/**
 * Get account by ID
 */
export const getAccountOptions = (options: Options<GetAccountData>) => queryOptions<GetAccountResponse, DefaultError, GetAccountResponse, ReturnType<typeof getAccountQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAccount({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAccountQueryKey(options)
});

/**
 * Update an account
 */
export const updateAccountMutation = (options?: Partial<Options<UpdateAccountData>>): UseMutationOptions<UpdateAccountResponse, DefaultError, Options<UpdateAccountData>> => {
    const mutationOptions: UseMutationOptions<UpdateAccountResponse, DefaultError, Options<UpdateAccountData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAccount({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAccountBalanceQueryKey = (options: Options<GetAccountBalanceData>) => createQueryKey('getAccountBalance', options);

/**
 * Get current balance for an account
 */
export const getAccountBalanceOptions = (options: Options<GetAccountBalanceData>) => queryOptions<GetAccountBalanceResponse, DefaultError, GetAccountBalanceResponse, ReturnType<typeof getAccountBalanceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAccountBalance({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAccountBalanceQueryKey(options)
});

export const getAccountBalanceHistoryQueryKey = (options: Options<GetAccountBalanceHistoryData>) => createQueryKey('getAccountBalanceHistory', options);

/**
 * Get historical balance snapshots for an account
 */
export const getAccountBalanceHistoryOptions = (options: Options<GetAccountBalanceHistoryData>) => queryOptions<GetAccountBalanceHistoryResponse, DefaultError, GetAccountBalanceHistoryResponse, ReturnType<typeof getAccountBalanceHistoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAccountBalanceHistory({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAccountBalanceHistoryQueryKey(options)
});

export const getAccountBalanceHistoryInfiniteQueryKey = (options: Options<GetAccountBalanceHistoryData>): QueryKey<Options<GetAccountBalanceHistoryData>> => createQueryKey('getAccountBalanceHistory', options, true);

/**
 * Get historical balance snapshots for an account
 */
export const getAccountBalanceHistoryInfiniteOptions = (options: Options<GetAccountBalanceHistoryData>) => infiniteQueryOptions<GetAccountBalanceHistoryResponse, DefaultError, InfiniteData<GetAccountBalanceHistoryResponse>, QueryKey<Options<GetAccountBalanceHistoryData>>, number | Pick<QueryKey<Options<GetAccountBalanceHistoryData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAccountBalanceHistoryData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAccountBalanceHistory({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAccountBalanceHistoryInfiniteQueryKey(options)
});

/**
 * Toggle archive status of an account
 */
export const toggleAccountArchiveMutation = (options?: Partial<Options<ToggleAccountArchiveData>>): UseMutationOptions<ToggleAccountArchiveResponse, DefaultError, Options<ToggleAccountArchiveData>> => {
    const mutationOptions: UseMutationOptions<ToggleAccountArchiveResponse, DefaultError, Options<ToggleAccountArchiveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await toggleAccountArchive({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listBudgetsQueryKey = (options: Options<ListBudgetsData>) => createQueryKey('listBudgets', options);

/**
 * List all budgets for a household (with computed totals)
 */
export const listBudgetsOptions = (options: Options<ListBudgetsData>) => queryOptions<ListBudgetsResponse, DefaultError, ListBudgetsResponse, ReturnType<typeof listBudgetsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listBudgets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBudgetsQueryKey(options)
});

export const listBudgetsInfiniteQueryKey = (options: Options<ListBudgetsData>): QueryKey<Options<ListBudgetsData>> => createQueryKey('listBudgets', options, true);

/**
 * List all budgets for a household (with computed totals)
 */
export const listBudgetsInfiniteOptions = (options: Options<ListBudgetsData>) => infiniteQueryOptions<ListBudgetsResponse, DefaultError, InfiniteData<ListBudgetsResponse>, QueryKey<Options<ListBudgetsData>>, number | Pick<QueryKey<Options<ListBudgetsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListBudgetsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listBudgets({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBudgetsInfiniteQueryKey(options)
});

/**
 * Create a new budget
 */
export const createBudgetMutation = (options?: Partial<Options<CreateBudgetData>>): UseMutationOptions<CreateBudgetResponse, DefaultError, Options<CreateBudgetData>> => {
    const mutationOptions: UseMutationOptions<CreateBudgetResponse, DefaultError, Options<CreateBudgetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBudget({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a budget (cascades to transactions and bills)
 */
export const deleteBudgetMutation = (options?: Partial<Options<DeleteBudgetData>>): UseMutationOptions<DeleteBudgetResponse, DefaultError, Options<DeleteBudgetData>> => {
    const mutationOptions: UseMutationOptions<DeleteBudgetResponse, DefaultError, Options<DeleteBudgetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBudget({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBudgetQueryKey = (options: Options<GetBudgetData>) => createQueryKey('getBudget', options);

/**
 * Get a specific budget with related details
 */
export const getBudgetOptions = (options: Options<GetBudgetData>) => queryOptions<GetBudgetResponse, DefaultError, GetBudgetResponse, ReturnType<typeof getBudgetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBudget({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBudgetQueryKey(options)
});

/**
 * Update a budget
 */
export const updateBudgetMutation = (options?: Partial<Options<UpdateBudgetData>>): UseMutationOptions<UpdateBudgetResponse, DefaultError, Options<UpdateBudgetData>> => {
    const mutationOptions: UseMutationOptions<UpdateBudgetResponse, DefaultError, Options<UpdateBudgetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBudget({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBudgetSnapshotHistoryQueryKey = (options: Options<GetBudgetSnapshotHistoryData>) => createQueryKey('getBudgetSnapshotHistory', options);

/**
 * Get historical snapshots for a budget
 */
export const getBudgetSnapshotHistoryOptions = (options: Options<GetBudgetSnapshotHistoryData>) => queryOptions<GetBudgetSnapshotHistoryResponse, DefaultError, GetBudgetSnapshotHistoryResponse, ReturnType<typeof getBudgetSnapshotHistoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBudgetSnapshotHistory({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBudgetSnapshotHistoryQueryKey(options)
});

export const getBudgetSnapshotHistoryInfiniteQueryKey = (options: Options<GetBudgetSnapshotHistoryData>): QueryKey<Options<GetBudgetSnapshotHistoryData>> => createQueryKey('getBudgetSnapshotHistory', options, true);

/**
 * Get historical snapshots for a budget
 */
export const getBudgetSnapshotHistoryInfiniteOptions = (options: Options<GetBudgetSnapshotHistoryData>) => infiniteQueryOptions<GetBudgetSnapshotHistoryResponse, DefaultError, InfiniteData<GetBudgetSnapshotHistoryResponse>, QueryKey<Options<GetBudgetSnapshotHistoryData>>, number | Pick<QueryKey<Options<GetBudgetSnapshotHistoryData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetBudgetSnapshotHistoryData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getBudgetSnapshotHistory({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBudgetSnapshotHistoryInfiniteQueryKey(options)
});

/**
 * Unlink a category from a budget
 */
export const unlinkCategoryFromBudgetMutation = (options?: Partial<Options<UnlinkCategoryFromBudgetData>>): UseMutationOptions<unknown, DefaultError, Options<UnlinkCategoryFromBudgetData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnlinkCategoryFromBudgetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unlinkCategoryFromBudget({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Link a category to a budget
 */
export const linkCategoryToBudgetMutation = (options?: Partial<Options<LinkCategoryToBudgetData>>): UseMutationOptions<unknown, DefaultError, Options<LinkCategoryToBudgetData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<LinkCategoryToBudgetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await linkCategoryToBudget({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Unlink an account from a budget
 */
export const unlinkAccountFromBudgetMutation = (options?: Partial<Options<UnlinkAccountFromBudgetData>>): UseMutationOptions<unknown, DefaultError, Options<UnlinkAccountFromBudgetData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UnlinkAccountFromBudgetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await unlinkAccountFromBudget({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Link an account to a budget
 */
export const linkAccountToBudgetMutation = (options?: Partial<Options<LinkAccountToBudgetData>>): UseMutationOptions<unknown, DefaultError, Options<LinkAccountToBudgetData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<LinkAccountToBudgetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await linkAccountToBudget({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listCategoriesQueryKey = (options: Options<ListCategoriesData>) => createQueryKey('listCategories', options);

/**
 * List categories for a household
 */
export const listCategoriesOptions = (options: Options<ListCategoriesData>) => queryOptions<ListCategoriesResponse, DefaultError, ListCategoriesResponse, ReturnType<typeof listCategoriesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listCategories({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listCategoriesQueryKey(options)
});

export const listCategoriesInfiniteQueryKey = (options: Options<ListCategoriesData>): QueryKey<Options<ListCategoriesData>> => createQueryKey('listCategories', options, true);

/**
 * List categories for a household
 */
export const listCategoriesInfiniteOptions = (options: Options<ListCategoriesData>) => infiniteQueryOptions<ListCategoriesResponse, DefaultError, InfiniteData<ListCategoriesResponse>, QueryKey<Options<ListCategoriesData>>, number | Pick<QueryKey<Options<ListCategoriesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListCategoriesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listCategories({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listCategoriesInfiniteQueryKey(options)
});

/**
 * Create a new category
 */
export const createCategoryMutation = (options?: Partial<Options<CreateCategoryData>>): UseMutationOptions<CreateCategoryResponse, DefaultError, Options<CreateCategoryData>> => {
    const mutationOptions: UseMutationOptions<CreateCategoryResponse, DefaultError, Options<CreateCategoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCategory({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a category (must have no transactions)
 */
export const deleteCategoryMutation = (options?: Partial<Options<DeleteCategoryData>>): UseMutationOptions<DeleteCategoryResponse, DefaultError, Options<DeleteCategoryData>> => {
    const mutationOptions: UseMutationOptions<DeleteCategoryResponse, DefaultError, Options<DeleteCategoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCategory({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCategoryQueryKey = (options: Options<GetCategoryData>) => createQueryKey('getCategory', options);

/**
 * Get a category by ID
 */
export const getCategoryOptions = (options: Options<GetCategoryData>) => queryOptions<GetCategoryResponse, DefaultError, GetCategoryResponse, ReturnType<typeof getCategoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCategory({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCategoryQueryKey(options)
});

/**
 * Update a category
 */
export const updateCategoryMutation = (options?: Partial<Options<UpdateCategoryData>>): UseMutationOptions<UpdateCategoryResponse, DefaultError, Options<UpdateCategoryData>> => {
    const mutationOptions: UseMutationOptions<UpdateCategoryResponse, DefaultError, Options<UpdateCategoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCategory({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listAllocationsQueryKey = (options: Options<ListAllocationsData>) => createQueryKey('listAllocations', options);

/**
 * List allocations for a budget
 */
export const listAllocationsOptions = (options: Options<ListAllocationsData>) => queryOptions<ListAllocationsResponse, DefaultError, ListAllocationsResponse, ReturnType<typeof listAllocationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listAllocations({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAllocationsQueryKey(options)
});

export const listAllocationsInfiniteQueryKey = (options: Options<ListAllocationsData>): QueryKey<Options<ListAllocationsData>> => createQueryKey('listAllocations', options, true);

/**
 * List allocations for a budget
 */
export const listAllocationsInfiniteOptions = (options: Options<ListAllocationsData>) => infiniteQueryOptions<ListAllocationsResponse, DefaultError, InfiniteData<ListAllocationsResponse>, QueryKey<Options<ListAllocationsData>>, number | Pick<QueryKey<Options<ListAllocationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListAllocationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAllocations({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAllocationsInfiniteQueryKey(options)
});

/**
 * Add funds to a budget
 */
export const createAllocationMutation = (options?: Partial<Options<CreateAllocationData>>): UseMutationOptions<CreateAllocationResponse, DefaultError, Options<CreateAllocationData>> => {
    const mutationOptions: UseMutationOptions<CreateAllocationResponse, DefaultError, Options<CreateAllocationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAllocation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Transfer funds between budgets
 */
export const transferAllocationMutation = (options?: Partial<Options<TransferAllocationData>>): UseMutationOptions<TransferAllocationResponse, DefaultError, Options<TransferAllocationData>> => {
    const mutationOptions: UseMutationOptions<TransferAllocationResponse, DefaultError, Options<TransferAllocationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await transferAllocation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUnallocatedFundsQueryKey = (options: Options<GetUnallocatedFundsData>) => createQueryKey('getUnallocatedFunds', options);

/**
 * Get total unallocated funds for a household
 */
export const getUnallocatedFundsOptions = (options: Options<GetUnallocatedFundsData>) => queryOptions<GetUnallocatedFundsResponse, DefaultError, GetUnallocatedFundsResponse, ReturnType<typeof getUnallocatedFundsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUnallocatedFunds({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUnallocatedFundsQueryKey(options)
});

export const listTransactionsQueryKey = (options?: Options<ListTransactionsData>) => createQueryKey('listTransactions', options);

/**
 * List transactions (must provide budgetId or householdId)
 */
export const listTransactionsOptions = (options?: Options<ListTransactionsData>) => queryOptions<ListTransactionsResponse, DefaultError, ListTransactionsResponse, ReturnType<typeof listTransactionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listTransactions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listTransactionsQueryKey(options)
});

export const listTransactionsInfiniteQueryKey = (options?: Options<ListTransactionsData>): QueryKey<Options<ListTransactionsData>> => createQueryKey('listTransactions', options, true);

/**
 * List transactions (must provide budgetId or householdId)
 */
export const listTransactionsInfiniteOptions = (options?: Options<ListTransactionsData>) => infiniteQueryOptions<ListTransactionsResponse, DefaultError, InfiniteData<ListTransactionsResponse>, QueryKey<Options<ListTransactionsData>>, number | Pick<QueryKey<Options<ListTransactionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListTransactionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listTransactions({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listTransactionsInfiniteQueryKey(options)
});

/**
 * Create a new transaction
 *
 * Supports inline category creation via `newCategory`, inline recipient creation via `newRecipientName`,
 * and transaction splits. When paying a bill (`billId`), automatically generates next bill instance.
 *
 */
export const createTransactionMutation = (options?: Partial<Options<CreateTransactionData>>): UseMutationOptions<CreateTransactionResponse, DefaultError, Options<CreateTransactionData>> => {
    const mutationOptions: UseMutationOptions<CreateTransactionResponse, DefaultError, Options<CreateTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a transaction
 */
export const deleteTransactionMutation = (options?: Partial<Options<DeleteTransactionData>>): UseMutationOptions<DeleteTransactionResponse, DefaultError, Options<DeleteTransactionData>> => {
    const mutationOptions: UseMutationOptions<DeleteTransactionResponse, DefaultError, Options<DeleteTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTransactionQueryKey = (options: Options<GetTransactionData>) => createQueryKey('getTransaction', options);

/**
 * Get a transaction by ID
 */
export const getTransactionOptions = (options: Options<GetTransactionData>) => queryOptions<GetTransactionResponse, DefaultError, GetTransactionResponse, ReturnType<typeof getTransactionQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTransaction({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTransactionQueryKey(options)
});

/**
 * Update a transaction
 */
export const updateTransactionMutation = (options?: Partial<Options<UpdateTransactionData>>): UseMutationOptions<UpdateTransactionResponse, DefaultError, Options<UpdateTransactionData>> => {
    const mutationOptions: UseMutationOptions<UpdateTransactionResponse, DefaultError, Options<UpdateTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Clone a transaction (defaults to today's date)
 */
export const cloneTransactionMutation = (options?: Partial<Options<CloneTransactionData>>): UseMutationOptions<CloneTransactionResponse, DefaultError, Options<CloneTransactionData>> => {
    const mutationOptions: UseMutationOptions<CloneTransactionResponse, DefaultError, Options<CloneTransactionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await cloneTransaction({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTransactionsGroupedByCategoryQueryKey = (options: Options<GetTransactionsGroupedByCategoryData>) => createQueryKey('getTransactionsGroupedByCategory', options);

/**
 * Get transactions grouped by category
 */
export const getTransactionsGroupedByCategoryOptions = (options: Options<GetTransactionsGroupedByCategoryData>) => queryOptions<GetTransactionsGroupedByCategoryResponse, DefaultError, GetTransactionsGroupedByCategoryResponse, ReturnType<typeof getTransactionsGroupedByCategoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTransactionsGroupedByCategory({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTransactionsGroupedByCategoryQueryKey(options)
});

export const getTransactionsGroupedByCategoryInfiniteQueryKey = (options: Options<GetTransactionsGroupedByCategoryData>): QueryKey<Options<GetTransactionsGroupedByCategoryData>> => createQueryKey('getTransactionsGroupedByCategory', options, true);

/**
 * Get transactions grouped by category
 */
export const getTransactionsGroupedByCategoryInfiniteOptions = (options: Options<GetTransactionsGroupedByCategoryData>) => infiniteQueryOptions<GetTransactionsGroupedByCategoryResponse, DefaultError, InfiniteData<GetTransactionsGroupedByCategoryResponse>, QueryKey<Options<GetTransactionsGroupedByCategoryData>>, number | Pick<QueryKey<Options<GetTransactionsGroupedByCategoryData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetTransactionsGroupedByCategoryData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getTransactionsGroupedByCategory({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTransactionsGroupedByCategoryInfiniteQueryKey(options)
});

export const listBillsQueryKey = (options: Options<ListBillsData>) => createQueryKey('listBills', options);

/**
 * List bill instances for a budget
 */
export const listBillsOptions = (options: Options<ListBillsData>) => queryOptions<ListBillsResponse, DefaultError, ListBillsResponse, ReturnType<typeof listBillsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listBills({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBillsQueryKey(options)
});

export const listBillsInfiniteQueryKey = (options: Options<ListBillsData>): QueryKey<Options<ListBillsData>> => createQueryKey('listBills', options, true);

/**
 * List bill instances for a budget
 */
export const listBillsInfiniteOptions = (options: Options<ListBillsData>) => infiniteQueryOptions<ListBillsResponse, DefaultError, InfiniteData<ListBillsResponse>, QueryKey<Options<ListBillsData>>, number | Pick<QueryKey<Options<ListBillsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListBillsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listBills({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBillsInfiniteQueryKey(options)
});

/**
 * Create a new recurring bill (generates instances up to 2 months ahead)
 *
 * Creates a recurring bill template and generates bill instances up to 2 months ahead.
 * A daily cron job generates additional instances as needed.
 *
 */
export const createBillMutation = (options?: Partial<Options<CreateBillData>>): UseMutationOptions<CreateBillResponse, DefaultError, Options<CreateBillData>> => {
    const mutationOptions: UseMutationOptions<CreateBillResponse, DefaultError, Options<CreateBillData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBill({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a recurring bill and all its instances
 */
export const deleteBillMutation = (options?: Partial<Options<DeleteBillData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteBillData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteBillData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBill({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a recurring bill (regenerates future unpaid instances on schedule change)
 *
 * The `billId` here is the **Bill** ID (the template), not the instance ID.
 * Changing schedule parameters (startDate, recurrenceType, customIntervalDays, lastPaymentDate, estimatedAmount)
 * will delete all future unpaid bill instances and regenerate them.
 *
 */
export const updateBillMutation = (options?: Partial<Options<UpdateBillData>>): UseMutationOptions<UpdateBillResponse, DefaultError, Options<UpdateBillData>> => {
    const mutationOptions: UseMutationOptions<UpdateBillResponse, DefaultError, Options<UpdateBillData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBill({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Archive or unarchive a recurring bill
 */
export const archiveBillMutation = (options?: Partial<Options<ArchiveBillData>>): UseMutationOptions<ArchiveBillResponse, DefaultError, Options<ArchiveBillData>> => {
    const mutationOptions: UseMutationOptions<ArchiveBillResponse, DefaultError, Options<ArchiveBillData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await archiveBill({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBillInstanceQueryKey = (options: Options<GetBillInstanceData>) => createQueryKey('getBillInstance', options);

/**
 * Get a specific bill instance
 */
export const getBillInstanceOptions = (options: Options<GetBillInstanceData>) => queryOptions<GetBillInstanceResponse, DefaultError, GetBillInstanceResponse, ReturnType<typeof getBillInstanceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBillInstance({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBillInstanceQueryKey(options)
});

/**
 * Update a specific bill instance, optionally applying to future instances
 */
export const updateBillInstanceMutation = (options?: Partial<Options<UpdateBillInstanceData>>): UseMutationOptions<UpdateBillInstanceResponse, DefaultError, Options<UpdateBillInstanceData>> => {
    const mutationOptions: UseMutationOptions<UpdateBillInstanceResponse, DefaultError, Options<UpdateBillInstanceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBillInstance({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTransfersQueryKey = (options: Options<ListTransfersData>) => createQueryKey('listTransfers', options);

/**
 * List transfers for a budget
 */
export const listTransfersOptions = (options: Options<ListTransfersData>) => queryOptions<ListTransfersResponse, DefaultError, ListTransfersResponse, ReturnType<typeof listTransfersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listTransfers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listTransfersQueryKey(options)
});

export const listTransfersInfiniteQueryKey = (options: Options<ListTransfersData>): QueryKey<Options<ListTransfersData>> => createQueryKey('listTransfers', options, true);

/**
 * List transfers for a budget
 */
export const listTransfersInfiniteOptions = (options: Options<ListTransfersData>) => infiniteQueryOptions<ListTransfersResponse, DefaultError, InfiniteData<ListTransfersResponse>, QueryKey<Options<ListTransfersData>>, number | Pick<QueryKey<Options<ListTransfersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListTransfersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listTransfers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listTransfersInfiniteQueryKey(options)
});

/**
 * Create a transfer between accounts
 */
export const createTransferMutation = (options?: Partial<Options<CreateTransferData>>): UseMutationOptions<CreateTransferResponse, DefaultError, Options<CreateTransferData>> => {
    const mutationOptions: UseMutationOptions<CreateTransferResponse, DefaultError, Options<CreateTransferData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTransfer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a transfer
 */
export const deleteTransferMutation = (options?: Partial<Options<DeleteTransferData>>): UseMutationOptions<DeleteTransferResponse, DefaultError, Options<DeleteTransferData>> => {
    const mutationOptions: UseMutationOptions<DeleteTransferResponse, DefaultError, Options<DeleteTransferData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTransfer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a transfer
 */
export const updateTransferMutation = (options?: Partial<Options<UpdateTransferData>>): UseMutationOptions<UpdateTransferResponse, DefaultError, Options<UpdateTransferData>> => {
    const mutationOptions: UseMutationOptions<UpdateTransferResponse, DefaultError, Options<UpdateTransferData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTransfer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listIncomesQueryKey = (options: Options<ListIncomesData>) => createQueryKey('listIncomes', options);

/**
 * List recurring income sources for a household
 */
export const listIncomesOptions = (options: Options<ListIncomesData>) => queryOptions<ListIncomesResponse, DefaultError, ListIncomesResponse, ReturnType<typeof listIncomesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listIncomes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listIncomesQueryKey(options)
});

export const listIncomesInfiniteQueryKey = (options: Options<ListIncomesData>): QueryKey<Options<ListIncomesData>> => createQueryKey('listIncomes', options, true);

/**
 * List recurring income sources for a household
 */
export const listIncomesInfiniteOptions = (options: Options<ListIncomesData>) => infiniteQueryOptions<ListIncomesResponse, DefaultError, InfiniteData<ListIncomesResponse>, QueryKey<Options<ListIncomesData>>, number | Pick<QueryKey<Options<ListIncomesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListIncomesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listIncomes({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listIncomesInfiniteQueryKey(options)
});

/**
 * Create a new income source
 */
export const createIncomeMutation = (options?: Partial<Options<CreateIncomeData>>): UseMutationOptions<CreateIncomeResponse, DefaultError, Options<CreateIncomeData>> => {
    const mutationOptions: UseMutationOptions<CreateIncomeResponse, DefaultError, Options<CreateIncomeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createIncome({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an income source
 */
export const deleteIncomeMutation = (options?: Partial<Options<DeleteIncomeData>>): UseMutationOptions<DeleteIncomeResponse, DefaultError, Options<DeleteIncomeData>> => {
    const mutationOptions: UseMutationOptions<DeleteIncomeResponse, DefaultError, Options<DeleteIncomeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteIncome({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getIncomeQueryKey = (options: Options<GetIncomeData>) => createQueryKey('getIncome', options);

/**
 * Get an income source by ID
 */
export const getIncomeOptions = (options: Options<GetIncomeData>) => queryOptions<GetIncomeResponse, DefaultError, GetIncomeResponse, ReturnType<typeof getIncomeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getIncome({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getIncomeQueryKey(options)
});

/**
 * Update an income source
 */
export const updateIncomeMutation = (options?: Partial<Options<UpdateIncomeData>>): UseMutationOptions<UpdateIncomeResponse, DefaultError, Options<UpdateIncomeData>> => {
    const mutationOptions: UseMutationOptions<UpdateIncomeResponse, DefaultError, Options<UpdateIncomeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateIncome({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Archive or unarchive an income source
 */
export const archiveIncomeMutation = (options?: Partial<Options<ArchiveIncomeData>>): UseMutationOptions<ArchiveIncomeResponse, DefaultError, Options<ArchiveIncomeData>> => {
    const mutationOptions: UseMutationOptions<ArchiveIncomeResponse, DefaultError, Options<ArchiveIncomeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await archiveIncome({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRecipientsQueryKey = (options: Options<ListRecipientsData>) => createQueryKey('listRecipients', options);

/**
 * List recipients for a household
 */
export const listRecipientsOptions = (options: Options<ListRecipientsData>) => queryOptions<ListRecipientsResponse, DefaultError, ListRecipientsResponse, ReturnType<typeof listRecipientsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listRecipients({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listRecipientsQueryKey(options)
});

export const listRecipientsInfiniteQueryKey = (options: Options<ListRecipientsData>): QueryKey<Options<ListRecipientsData>> => createQueryKey('listRecipients', options, true);

/**
 * List recipients for a household
 */
export const listRecipientsInfiniteOptions = (options: Options<ListRecipientsData>) => infiniteQueryOptions<ListRecipientsResponse, DefaultError, InfiniteData<ListRecipientsResponse>, QueryKey<Options<ListRecipientsData>>, number | Pick<QueryKey<Options<ListRecipientsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListRecipientsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listRecipients({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listRecipientsInfiniteQueryKey(options)
});

/**
 * Create a new recipient (fails if name already exists)
 */
export const createRecipientMutation = (options?: Partial<Options<CreateRecipientData>>): UseMutationOptions<CreateRecipientResponse, DefaultError, Options<CreateRecipientData>> => {
    const mutationOptions: UseMutationOptions<CreateRecipientResponse, DefaultError, Options<CreateRecipientData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createRecipient({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Get existing or create new recipient by name
 */
export const getOrCreateRecipientMutation = (options?: Partial<Options<GetOrCreateRecipientData>>): UseMutationOptions<GetOrCreateRecipientResponse, DefaultError, Options<GetOrCreateRecipientData>> => {
    const mutationOptions: UseMutationOptions<GetOrCreateRecipientResponse, DefaultError, Options<GetOrCreateRecipientData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await getOrCreateRecipient({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a recipient
 */
export const deleteRecipientMutation = (options?: Partial<Options<DeleteRecipientData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteRecipientData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteRecipientData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteRecipient({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRecipientQueryKey = (options: Options<GetRecipientData>) => createQueryKey('getRecipient', options);

/**
 * Get a recipient by ID
 */
export const getRecipientOptions = (options: Options<GetRecipientData>) => queryOptions<GetRecipientResponse, DefaultError, GetRecipientResponse, ReturnType<typeof getRecipientQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRecipient({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRecipientQueryKey(options)
});

/**
 * Update a recipient
 */
export const updateRecipientMutation = (options?: Partial<Options<UpdateRecipientData>>): UseMutationOptions<UpdateRecipientResponse, DefaultError, Options<UpdateRecipientData>> => {
    const mutationOptions: UseMutationOptions<UpdateRecipientResponse, DefaultError, Options<UpdateRecipientData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateRecipient({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listMyInvitationsQueryKey = (options?: Options<ListMyInvitationsData>) => createQueryKey('listMyInvitations', options);

/**
 * List pending invitations for the authenticated user (by email via Clerk)
 */
export const listMyInvitationsOptions = (options?: Options<ListMyInvitationsData>) => queryOptions<ListMyInvitationsResponse, DefaultError, ListMyInvitationsResponse, ReturnType<typeof listMyInvitationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listMyInvitations({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listMyInvitationsQueryKey(options)
});

export const listMyInvitationsInfiniteQueryKey = (options?: Options<ListMyInvitationsData>): QueryKey<Options<ListMyInvitationsData>> => createQueryKey('listMyInvitations', options, true);

/**
 * List pending invitations for the authenticated user (by email via Clerk)
 */
export const listMyInvitationsInfiniteOptions = (options?: Options<ListMyInvitationsData>) => infiniteQueryOptions<ListMyInvitationsResponse, DefaultError, InfiniteData<ListMyInvitationsResponse>, QueryKey<Options<ListMyInvitationsData>>, number | Pick<QueryKey<Options<ListMyInvitationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListMyInvitationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMyInvitations({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listMyInvitationsInfiniteQueryKey(options)
});

export const listHouseholdInvitationsQueryKey = (options: Options<ListHouseholdInvitationsData>) => createQueryKey('listHouseholdInvitations', options);

/**
 * List pending invitations for a household
 */
export const listHouseholdInvitationsOptions = (options: Options<ListHouseholdInvitationsData>) => queryOptions<ListHouseholdInvitationsResponse, DefaultError, ListHouseholdInvitationsResponse, ReturnType<typeof listHouseholdInvitationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listHouseholdInvitations({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listHouseholdInvitationsQueryKey(options)
});

export const listHouseholdInvitationsInfiniteQueryKey = (options: Options<ListHouseholdInvitationsData>): QueryKey<Options<ListHouseholdInvitationsData>> => createQueryKey('listHouseholdInvitations', options, true);

/**
 * List pending invitations for a household
 */
export const listHouseholdInvitationsInfiniteOptions = (options: Options<ListHouseholdInvitationsData>) => infiniteQueryOptions<ListHouseholdInvitationsResponse, DefaultError, InfiniteData<ListHouseholdInvitationsResponse>, QueryKey<Options<ListHouseholdInvitationsData>>, number | Pick<QueryKey<Options<ListHouseholdInvitationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListHouseholdInvitationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listHouseholdInvitations({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listHouseholdInvitationsInfiniteQueryKey(options)
});

/**
 * Invite a user to a household by email
 */
export const createInvitationMutation = (options?: Partial<Options<CreateInvitationData>>): UseMutationOptions<CreateInvitationResponse, DefaultError, Options<CreateInvitationData>> => {
    const mutationOptions: UseMutationOptions<CreateInvitationResponse, DefaultError, Options<CreateInvitationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createInvitation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Accept an invitation (adds user to household)
 */
export const acceptInvitationMutation = (options?: Partial<Options<AcceptInvitationData>>): UseMutationOptions<unknown, DefaultError, Options<AcceptInvitationData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AcceptInvitationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await acceptInvitation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Decline an invitation
 */
export const declineInvitationMutation = (options?: Partial<Options<DeclineInvitationData>>): UseMutationOptions<unknown, DefaultError, Options<DeclineInvitationData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeclineInvitationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await declineInvitation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Revoke a pending invitation (by a household member)
 */
export const revokeInvitationMutation = (options?: Partial<Options<RevokeInvitationData>>): UseMutationOptions<unknown, DefaultError, Options<RevokeInvitationData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RevokeInvitationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await revokeInvitation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
